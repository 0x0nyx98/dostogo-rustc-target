- // MIR for `inner` before ConstProp
+ // MIR for `inner` after ConstProp
  
  fn inner(_1: u32) -> i64 {
      debug fields => _1;
      let mut _0: i64;
      let mut _2: i32;
      let mut _3: u32;
      let mut _4: u32;
      let mut _5: u32;
      let mut _6: u32;
      let mut _7: u32;
      scope 1 (inlined imm8) {
          debug x => _1;
          let mut _8: u32;
          let mut _9: u32;
          scope 2 {
              debug out => _4;
          }
      }
      scope 3 (inlined core::num::<impl u32>::rotate_right) {
          debug self => _4;
          debug n => _5;
      }
  
      bb0: {
          StorageLive(_2);
          StorageLive(_3);
          StorageLive(_4);
          _4 = const 0_u32;
          StorageLive(_9);
          StorageLive(_8);
          _8 = Shr(_1, const 0_i32);
          _9 = BitAnd(move _8, const 255_u32);
          StorageDead(_8);
          _4 = BitOr(const 0_u32, move _9);
          StorageDead(_9);
          StorageLive(_5);
          StorageLive(_6);
          StorageLive(_7);
          assert(const true, "attempt to shift right by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind continue];
      }
  
      bb1: {
          _7 = Shr(_1, const 8_i32);
          _6 = BitAnd(move _7, const 15_u32);
          StorageDead(_7);
          assert(const true, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb2, unwind continue];
      }
  
      bb2: {
          _5 = Shl(move _6, const 1_i32);
          StorageDead(_6);
          _3 = rotate_right::<u32>(move _4, move _5) -> [return: bb3, unwind unreachable];
      }
  
      bb3: {
          StorageDead(_5);
          StorageDead(_4);
          _2 = move _3 as i32 (IntToInt);
          StorageDead(_3);
          _0 = move _2 as i64 (IntToInt);
          StorageDead(_2);
          return;
      }
  }
  
